from src.modeling.base import BaseModel


class TemperatureModel(BaseModel):
    """
    Specialized trainer for Temperature forecasting.

    This class handles the regression tasks for three distinct variables:
    - Average Temperature (tmed)
    - Minimum Temperature (tmin)
    - Maximum Temperature (tmax)
    """

    def run_training(self):
        """
        Executes the training pipeline for all temperature targets.

        Workflow:
        1.  **Feature Engineering**: Generates historical context features:
            - **Lags**: Values from t-1, t-2, and t-7.
            - **Deltas (Trends)**: Difference between today and yesterday (Is it getting colder?).
            - **Rolling Means**: 3-day (immediate), 7-day (weekly) means.
        2.  **Data Splitting**: 3-Way Strategy (Train/Val/Test).
        3.  **Target Shifting**: Shifts the target variable by -1 day.
        4.  **Training**: Trains LightGBM regressors.

        Returns:
            pd.DataFrame: A dataframe containing the dates, station IDs, and predictions.
        """
        self.load_and_prepare()
        targets = ["tmed", "tmin", "tmax"]

        # --- Feature Engineering ---
        # 1. Create Lags (t-1, t-2, t-7)
        cols_lag = ["tmed", "tmin", "tmax", "presMin"]
        lags = [1, 2, 7]

        df_eng = self.df.copy()

        # A. LAGS
        for col in cols_lag:
            if col in df_eng.columns:
                for lag in lags:
                    df_eng[f"{col}_lag_{lag}"] = df_eng.groupby("indicativo")[
                        col
                    ].shift(lag)

        # B. DELTAS (TRENDS) - CRITICAL FOR SUDDEN CHANGES
        # Calculates: (Value Yesterday - Value 2 Days Ago)
        # Helps the model understand if temp is DROPPING or RISING.
        for col in ["tmed", "tmin", "tmax"]:
            if f"{col}_lag_1" in df_eng.columns and f"{col}_lag_2" in df_eng.columns:
                df_eng[f"{col}_trend"] = df_eng[f"{col}_lag_1"] - df_eng[f"{col}_lag_2"]

        # C. ROLLING WINDOWS (Moving Averages)
        # Added '3' day window to capture immediate inertia
        for w in [3, 7, 14]:
            if "tmed" in df_eng.columns:
                df_eng[f"tmed_roll_{w}"] = df_eng.groupby("indicativo")[
                    "tmed"
                ].transform(lambda x, window=w: x.rolling(window).mean())

        # Drop rows with NaNs generated by lags/rolling
        df_eng = df_eng.dropna()

        # --- Train/Validation/Test Split ---
        VAL_START = "2021-01-01"
        TEST_START = "2023-01-01"

        train = df_eng[df_eng["fecha"] < VAL_START]
        val = df_eng[(df_eng["fecha"] >= VAL_START) & (df_eng["fecha"] < TEST_START)]
        test = df_eng[df_eng["fecha"] >= TEST_START]

        results = test[["fecha", "indicativo"]].copy()

        # --- Training Loop ---
        for target in targets:
            if target not in df_eng.columns:
                continue

            # Target Shift: Predict NEXT day
            y_train = train.groupby("indicativo")[target].shift(-1).dropna()
            y_val = val.groupby("indicativo")[target].shift(-1).dropna()
            y_test = test.groupby("indicativo")[target].shift(-1).dropna()

            # Align X
            cols_drop = ["fecha", "indicativo", "nombre", "provincia"]

            X_train = train.loc[y_train.index].drop(columns=cols_drop)
            X_val = val.loc[y_val.index].drop(columns=cols_drop)
            X_test = test.loc[y_test.index].drop(columns=cols_drop)

            # Hyperparameter tuning for tighter fit
            # We lower 'num_leaves' slightly to prevent overfitting noise,
            # but increase 'learning_rate' slightly to react faster to trends.
            params = {
                "num_leaves": 25,  # Smaller trees to generalize better
                "learning_rate": 0.08,  # Slightly faster learning to catch trends
                "feature_fraction": 0.8,
            }

            preds = self.train_lgbm(
                X_train,
                y_train,
                X_val,
                y_val,
                X_test,
                y_test,
                target,
                custom_params=params,
            )

            results.loc[y_test.index, f"pred_{target}"] = preds

        results = results.dropna()

        return results
